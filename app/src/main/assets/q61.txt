关于在调用模板函数时模板实参的使用，下列表述中正确的是（　　）。

A．对于虚拟类型参数所对应的模板实参，如果能从模板函数的实参中获得相同的信息，则都可以省略

B．对于虚拟类型参数所对应的模板实参，如果它们是参数表中的最后的若干个参数，则都可以省略

C．对于虚拟类型参数所对应的模板实参，若能够省略则必须省略

D．对于常规参数所对应的模板实参，任何情况下都不能省略

4

解析：在调用一个模板函数时，编译系统需要足够的信息来判别每个虚拟类型参数所对应的实际类型，可以从两个不同的渠道获得这样的信息：从模板实参表(用“<>”括起来的参数表)或从模板函数实参表(用“()”括起来的参数表)。如果从后者获得的信息已经能够判定其中部分或全部虚拟类型参数所对应的实际参数，而且它们又正好是参数表中最后的若干参数，则模板实参表中的那几个参数可以省。如果模板实参表中的实参都被省了，则空表“<>”也可以不要，因此选项D错误。反之，对于某个模板实参，如果从模板函数的实参表中无法获得同样的信息，就不能省；或者虽然能够获得同样的信息，但在它后面还有其他不能省的实参，则其自身还是不能省。

有如下类定义： 
class MyBase{
int k； 
public： 
MyBase(int n=O)：k(n)}}
int value()eonst{return k；}
}； 
class MyDerived：MyBase{
intj； 
public： 
MyDerived(int i)：j(i)}}
int getK()const{return k；}
int getJ()const{return j；}
}； 
编译时发现有一处语法错误，对这个错误最准确的描述是（　　）。

A．函数9etK试图访问基类的私有成员变量k

B．在类MyDerived的定义中，基类名MyBase前缺少关键字public、protected或private

C．类MyDerived缺少一个无参的构造函数

D．类MyDerived的构造函数没有对基类数据成员k进行初始化

1

解析：默认继承方式为私有继承，私有继承将基类的公用成员和保护成员都变为r私有成员，基类的私有成员依然属于基类私有，派生类不能访问基类的私有成员。所以A选项正确

在长度为n的有序线性表中进行二分查找，最坏情况下需要比较的次数是（　　）。

A．O(n)

B．O(n2)

C．O(10g2n)

D．0(n10gn)

3

解析：当有序线性表为顺序存储时才能用：二分法查找。可以证明的是对于长度为n的有序线性表，在最坏情况下，二分法查找只需要比较l0g2n次，而顺序查找需要比较n次。
